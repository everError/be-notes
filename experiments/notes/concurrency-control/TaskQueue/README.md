# KeyedTaskQueue — 키 기반 비동기 순차 작업 처리 도구

## 문제 상황

- **트랜잭션 충돌 및 교착 상태**: 동일한 행(Row)을 동시에 수정하려 할 때 발생
- **중복 키 삽입 오류**: 아직 커밋되지 않은 상태에서 여러 요청이 동시에 INSERT를 시도할 때 발생
- **정합성 문제**: UPDATE 연산 순서가 보장되지 않아 누적 계산이 어긋나는 현상

## 해결 방안으로 고안한 처리 방식

- 동일 키에 대한 요청이 병렬로 실행되지 않도록 막고,
- 순차적으로 실행되어 연산 순서를 보장하며,
- 요청마다 처리 결과를 정확히 반환할 수 있도록 한다.

## 구현 개념 요약

- `.NET의 Channel<T>`를 활용해 작업을 순서대로 처리
- `ConcurrentDictionary`를 통해 키마다 독립적인 Channel 생성
- `TaskCompletionSource`로 호출자의 응답 흐름을 외부에서 비동기 제어

## 작동 구조

1. 요청이 들어오면 고유 키를 기준으로 큐에 등록됨
2. 큐가 없으면 새로 만들어지고 처리 루틴이 시작됨
3. 각 작업은 순서대로 실행되며 완료될 때까지 다음 요청은 대기
4. 호출자는 자신의 작업이 완료될 때까지 기다리고, 결과 또는 예외를 반환받음

## 사용 예시 (포인트 적립)

예를 들어 사용자 ID 기준으로 포인트 적립 요청이 동시에 들어오는 상황을 가정:

```csharp
await _keyedQueue.EnqueueAsync(userId.ToString(), async () =>
{
    await _pointService.AddAsync(userId, 100);
    await _pointService.AddHistoryAsync(userId, "이벤트 참여");

    await _context.SaveChangesAsync();
    return new { success = true };
});
```

## 효과

동일한 키 일 경우:

- 먼저 도착한 요청부터 순차적으로 실행
- 다음 요청은 앞선 작업이 끝날 때까지 대기
- 각각의 요청은 정확한 연산 결과를 수신

- 교착 상태 발생 방지
- 중복 삽입으로 인한 예외 방지
- UPDATE 연산 누적 오류 방지

## 주의할 점

- 이 구조는 메모리 기반이며, 하나의 애플리케이션 인스턴스 내에서만 동작한다.
- 다중 인스턴스로 구성된 환경에서는 동일 키의 순서 보장이 어려울 수 있다.

## 요약

여러 요청이 동시에 같은 데이터를 처리하려 할 때 발생하는 문제를 해결하기 위해, 키 기반의 순차 처리 큐를 구현
