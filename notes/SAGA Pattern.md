# 사가 패턴 (Saga Pattern)

## 1. 개요

사가 패턴은 마이크로서비스 아키텍처(MSA) 환경에서 분산 시스템 간의 **데이터 일관성**을 유지하기 위한 트랜잭션 관리 패턴입니다. 단일 서비스 내의 ACID 트랜잭션과 달리, 여러 서비스에 걸친 비즈니스 프로세스를 원자적인 단위처럼 관리해야 할 때 사용됩니다.

하나의 큰 글로벌 트랜잭션(Global Transaction)을 사용하는 대신, 여러 개의 작은 **로컬 트랜잭션(Local Transaction)**의 연속으로 구성합니다. 각 로컬 트랜잭션은 특정 서비스 내에서 데이터 일관성을 보장하며, 이들의 순차적인 실행이 전체 비즈니스 프로세스를 완성시킵니다.

만약 사가(Saga)의 여러 단계 중 하나라도 실패할 경우, 이전에 성공했던 단계들을 **보상 트랜잭션(Compensating Transaction)**을 통해 순차적으로 롤백하여 데이터의 최종 일관성(Eventually Consistent)을 보장합니다.

***

## 2. 핵심 구성 요소

* **로컬 트랜잭션 (Local Transaction)**: 사가를 구성하는 개별 단계로, 단일 마이크로서비스 내에서 실행되는 원자적(ACID) 트랜잭션입니다.
* **보상 트랜잭션 (Compensating Transaction)**: 로컬 트랜잭션이 실패했을 때, 이미 완료된 이전 단계의 작업을 되돌리기 위해 실행되는 트랜잭션입니다. 보상 트랜잭션은 반드시 성공해야 하며, 멱등성(idempotent)을 가지도록 설계하는 것이 중요합니다.

***

## 3. 구현 방식

사가 패턴은 주로 두 가지 방식으로 구현됩니다: **코레오그래피(Choreography)**와 **오케스트레이션(Orchestration)**.

### 3.1. 코레오그래피 (Choreography, 안무 방식)

#### 개념
중앙 조정자 없이 각 마이크로서비스가 **이벤트(Event)**를 구독(Subscribe)하고 발행(Publish)함으로써 서로의 작업을 트리거하는 방식입니다. 서비스들은 이벤트 버스(메시지 큐 등)를 통해 서로 통신하며, 자신이 수행해야 할 작업이 무엇인지 스스로 인지하고 실행합니다.



#### 흐름 예시 (주문, 재고, 결제)
1.  **주문 서비스**: `OrderCreated` 이벤트를 발행합니다.
2.  **재고 서비스**: `OrderCreated` 이벤트를 구독하고, 재고를 감소시키는 로컬 트랜잭션을 실행한 후 `StockUpdated` 이벤트를 발행합니다.
3.  **결제 서비스**: `StockUpdated` 이벤트를 구독하고, 결제를 처리하는 로컬 트랜잭션을 실행한 후 `PaymentProcessed` 이벤트를 발행합니다.

* **실패 시**: 결제 서비스가 실패하면 `PaymentFailed` 이벤트를 발행하고, 재고 서비스와 주문 서비스는 이 이벤트를 구독하여 각각 재고를 복원하고 주문 상태를 '실패'로 변경하는 보상 트랜잭션을 실행합니다.

#### 장점
* **단순함과 느슨한 결합**: 각 서비스는 다른 서비스를 직접 호출할 필요 없이 이벤트에만 의존하므로 결합도가 낮습니다.
* **쉬운 서비스 추가/제거**: 새로운 서비스를 추가할 때 특정 이벤트만 구독하도록 구현하면 되므로 확장이 용이합니다.

#### 단점
* **전체 흐름 파악의 어려움**: 비즈니스 로직이 여러 서비스에 분산되어 있어 전체 트랜잭션의 흐름을 추적하고 디버깅하기 어렵습니다.
* **순환 종속성 위험**: 서비스들이 서로의 이벤트를 연쇄적으로 호출하다 보면 순환 종속성이 발생할 수 있습니다.
* **통합 테스트의 복잡성**: 모든 서비스가 실행되어야만 전체 프로세스를 테스트할 수 있습니다.

---

### 3.2. 오케스트레이션 (Orchestration, 지휘 방식)

#### 개념
**오케스트레이터(Orchestrator)** 또는 조정자(Coordinator)라는 중앙 서비스가 전체 비즈니스 프로세스의 흐름을 책임지고 관리하는 방식입니다. 오케스트레이터는 각 참여 서비스에게 수행할 작업을 명령(Command)하고, 그 결과를 받아 다음 단계를 결정합니다. BFF(Backend for Frontend) 컨트롤러나 별도의 워크플로우 관리 서비스가 이 역할을 수행할 수 있습니다.



#### 흐름 예시 (주문, 재고, 결제)
1.  **클라이언트**: 오케스트레이터에게 주문을 요청합니다.
2.  **오케스트레이터**:
    * **주문 서비스**에 주문 생성을 요청(호출)합니다.
    * 성공 시, **재고 서비스**에 재고 감소를 요청합니다.
    * 성공 시, **결제 서비스**에 결제를 요청합니다.
    * 모든 단계가 성공하면 클라이언트에게 최종 성공을 응답합니다.

* **실패 시**: 만약 결제 서비스 호출이 실패하면, 오케스트레이터는 **재고 서비스**에 재고 복원(보상 트랜잭션)을 요청하고, 이어서 **주문 서비스**에 주문 취소(보상 트랜잭션)를 요청합니다.

#### 장점
* **중앙 집중적인 관리**: 전체 비즈니스 로직과 트랜잭션 흐름이 오케스트레이터에 명확하게 정의되어 있어 이해하고 관리하기 쉽습니다.
* **낮은 서비스 간 의존성**: 참여 서비스들은 오케스트레이터와만 통신하며, 다른 서비스의 존재를 알 필요가 없습니다.
* **명확한 상태 관리**: 전체 사가의 현재 상태를 오케스트레이터에서 쉽게 파악할 수 있습니다.

#### 단점
* **오케스트레이터의 과도한 책임**: 비즈니스 로직이 오케스트레이터에 집중되어 이 서비스가 너무 거대해지고 단일 장애점(SPOF)이 될 수 있습니다.
* **서비스 결합도**: 참여 서비스들이 오케스트레이터에 종속되는 구조가 됩니다.

---

## 4. 사가 패턴 사용 시 고려사항

* **최종 일관성(Eventual Consistency)**: 사가 패턴은 모든 단계가 완료되기 전까지 데이터가 일시적으로 불일치 상태에 놓일 수 있습니다. 이러한 최종 일관성 모델이 비즈니스 요구사항에 부합하는지 반드시 검토해야 합니다.
* **보상 트랜잭션 설계**: 보상 트랜잭션은 실패 가능성이 거의 없도록 신뢰성 있게 설계해야 합니다. 또한, 여러 번 호출되어도 동일한 결과를 내도록 멱등성(Idempotency)을 확보하는 것이 중요합니다.
* **데이터 가시성**: 사가 진행 중에 다른 트랜잭션이 아직 커밋되지 않은 데이터를 읽지 못하도록 격리 수준(Isolation)을 신중하게 고려해야 합니다.

***

## 5. 결론

사가 패턴은 분산 환경에서 트랜잭션의 원자성을 보장하기 위한 강력한 솔루션입니다. **코레오그래피** 방식은 서비스가 적고 프로세스가 단순할 때 적합하며, **오케스트레이션** 방식은 프로세스가 복잡하고 여러 서비스가 관여할 때 중앙에서 흐름을 명확하게 제어할 수 있어 더 적합합니다. 프로젝트의 특성과 요구사항을 고려하여 적절한 구현 방식을 선택해야 합니다.