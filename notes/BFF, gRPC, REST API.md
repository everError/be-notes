### API 통신 방식 비교: BFF, gRPC, REST API

마이크로서비스 아키텍처(MSA)에서는 각 서비스의 역할과 통신 방식이 중요합니다. 클라이언트와의 통신, 그리고 서비스들 간의 통신에 적합한 기술을 선택하는 것이 중요하며, BFF, gRPC, REST API는 각각 다른 역할과 장점을 가지고 있습니다.

---

### 1. REST API (Representational State Transfer API)

REST는 웹의 기존 인프라(HTTP)를 효율적으로 활용하는 아키텍처 스타일입니다. URI(Uniform Resource Identifier)를 통해 자원을 식별하고, HTTP 메서드를 통해 자원에 대한 행위를 정의합니다.

- **핵심 원리:**

  - **리소스 기반:** 모든 것을 `URI`로 식별 가능한 자원(Resource)으로 간주합니다. (예: `/users`, `/products/1`)
  - **HTTP 메서드 활용:** `GET`(조회), `POST`(생성), `PUT`/`PATCH`(수정), `DELETE`(삭제)로 자원 행위를 정의합니다.
  - **무상태성(Stateless):** 서버는 클라이언트의 상태를 저장하지 않습니다. 각 요청은 독립적입니다.
  - **통신 포맷:** 주로 `JSON` 또는 `XML`과 같은 텍스트 기반 포맷을 사용합니다.

- **장점:**

  - 범용성 및 접근성이 매우 높습니다.
  - 자원 기반의 명확한 구조로 이해하기 쉽습니다.
  - HTTP 표준을 따르므로 학습 곡선이 낮습니다.
  - 클라이언트와 서버가 독립적으로 개발 가능합니다.

- **단점:**
  - 하나의 화면에 여러 API 호출이 필요할 수 있어 비효율적입니다.
  - 필요한 데이터보다 더 많은 데이터를 받을 수 있습니다.
  - 텍스트 기반 포맷으로 인해 성능 오버헤드가 발생할 수 있습니다.

---

### 2. gRPC (gRPC Remote Procedure Calls)

gRPC는 Google에서 개발한 고성능 RPC(원격 프로시저 호출) 프레임워크로, REST API의 비효율성을 극복하기 위해 주로 내부 시스템 간 통신에 사용됩니다.

- **핵심 원리:**

  - **HTTP/2 기반:** 멀티플렉싱, 헤더 압축 등으로 높은 성능을 제공합니다.
  - **Protocol Buffers:** `Protobuf`라는 이진 직렬화 포맷을 사용하여 데이터를 주고받습니다.
  - **서비스 정의:** `*.proto` 파일을 통해 서비스 인터페이스를 명확하게 정의합니다.
  - **코드 생성:** `Protobuf` 파일을 기반으로 다양한 언어의 클라이언트 및 서버 코드를 자동으로 생성합니다.

- **장점:**

  - HTTP/2와 `Protobuf`의 조합으로 통신 속도가 매우 빠르고 데이터 전송량이 적습니다.
  - `*.proto` 파일로 인터페이스가 명확히 정의되어 타입 안정성이 높습니다.
  - 다양한 언어를 지원하여 MSA 환경에 적합합니다.
  - 단방향, 양방향 스트리밍을 지원합니다.

- **단점:**
  - 브라우저에서 직접 호출하기 어렵습니다.
  - 이진 포맷이라 사람이 직접 내용을 확인하기 어렵습니다.
  - REST에 비해 학습 곡선이 높습니다.

---

### 3. BFF (Backend For Frontend)

BFF는 특정 클라이언트(웹, 모바일 등)에 최적화된 백엔드 레이어를 의미합니다. 클라이언트와 MSA의 핵심 서비스들 사이에 위치하며, 클라이언트의 요구사항에 맞게 데이터를 가공하고 통합하는 역할을 수행합니다.

- **핵심 원리:**

  - **클라이언트 중심 API:** 하나의 BFF가 하나의 프론트엔드에 대응하여 필요한 데이터만 제공합니다.
  - **데이터 통합:** 여러 마이크로서비스에 분산된 데이터를 한 번의 호출로 통합합니다.
  - **프론트엔드 로직 위임:** 프론트엔드에서 처리하던 복잡한 데이터 조작 로직을 BFF로 옮겨 개발을 간소화합니다.

- **장점:**

  - 클라이언트의 `UI/UX`에 맞춰 최적화된 API를 제공합니다.
  - 클라이언트의 통신 오버헤드를 줄이고 개발을 간소화합니다.
  - MSA의 복잡성을 클라이언트로부터 숨길 수 있습니다.
  - 클라이언트 요구사항 변경이 전체 시스템에 영향을 주지 않습니다.

- **단점:**
  - 클라이언트 종류가 늘어날수록 관리해야 할 서버가 많아집니다.
  - 추가적인 백엔드 레이어 관리로 시스템 복잡도가 증가할 수 있습니다.
  - 여러 백엔드 서비스를 호출하는 과정에서 병목 현상이 발생할 수 있습니다.

---

### 마이크로서비스 아키텍처(MSA)에서의 활용 패턴

| **구분**            | **클라이언트(Frontend)**                   | **BFF**                                        | **MSA 내부 서비스**                       |
| ------------------- | ------------------------------------------ | ---------------------------------------------- | ----------------------------------------- |
| **통신 방식**       | REST API                                   | REST API (클라이언트용)                        | gRPC (내부 서비스 간)                     |
| **주요 역할**       | API 호출 및 화면 구성                      | 클라이언트 요구사항에 맞게 데이터 통합 및 가공 | 비즈니스 로직 및 데이터 처리              |
| **통신 방향**       | 클라이언트 → BFF                           | BFF ↔ MSA 내부 서비스                          | 서비스 간 통신                            |

| **구분**            | **REST API**                                              | **gRPC**                                               | **BFF**                                                 |
| ------------------- | --------------------------------------------------------- | ------------------------------------------------------ | ------------------------------------------------------- |
| **통신 프로토콜**   | HTTP 1.1+                                                 | HTTP/2                                                 | REST API (HTTP)                                         |
| **데이터 형식**     | JSON, XML (텍스트 기반)                                   | Protocol Buffers (바이너리 기반)                       | JSON, XML (텍스트 기반)                                 |
| **성능**            | 상대적으로 느림                                           | **매우 빠름**                                          | REST API의 성능을 따르나, 내부 통신 최적화 가능         |
| **주요 사용처**     | **외부 공개 API**, 웹/모바일 클라이언트                   | **내부 서비스 간 통신**, 마이크로서비스                | **클라이언트 맞춤 API 제공**, MSA의 복잡성 은닉         |
| **API 정의**        | URI + HTTP 메서드                                         | `*.proto` 파일                                         | 클라이언트 요구사항에 따라 자유롭게 정의                |
| **타입 안정성**     | 타입 정보가 없어 런타임 오류 발생 가능                    | **강력한 타입** (코드 자동 생성)                       | 타입 정보가 없어 런타임 오류 발생 가능                  |
| **단방향/양방향**   | 단방향 통신                                               | **양방향 스트리밍 지원**                               | 단방향 통신                                             |
