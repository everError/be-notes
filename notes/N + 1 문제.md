### N + 1 문제: ORM 프레임워크에서의 성능 이슈

N + 1 문제는 ORM(Object-Relational Mapping) 프레임워크를 사용할 때 발생하는 대표적인 성능 이슈입니다. 이는 예상보다 많은 수의 데이터베이스 쿼리가 실행되어 애플리케이션의 성능을 저하시키는 현상을 의미합니다. 이 문제는 주로 연관 관계가 있는 엔티티를 조회할 때 발생합니다.

---

### 문제의 원인 및 발생 시나리오

#### JPA (Java Persistence API) - Hibernate 기준

JPA에서는 **지연 로딩(Lazy Loading)**이 기본 전략으로 설정된 경우가 많습니다. 연관된 엔티티를 프록시 객체로 가지고 있다가, 실제로 해당 객체에 접근할 때 데이터베이스 쿼리를 실행하여 데이터를 가져옵니다. 이때, 반복문을 통해 여러 개의 메인 엔티티에 접근하면서 각각의 연관 엔티티를 조회하게 되면 `1 + N`개의 쿼리가 발생합니다.

**예시:** '팀'과 '멤버'가 1:N 관계일 때, 모든 팀을 조회한 후 각 팀의 멤버 목록에 접근하는 경우

- **쿼리 1회:** 모든 `Team` 엔티티를 조회합니다.
- **쿼리 N회:** 반복문에서 각 `Team`의 `members` 컬렉션에 접근할 때마다, 해당 팀의 `Member`를 조회하는 쿼리가 N번 실행됩니다.

#### EF Core (Entity Framework Core) 기준

EF Core에서는 기본적으로 **지연 로딩**이 활성화되어 있지 않습니다. 하지만 `virtual` 키워드를 사용하거나 프록시를 설정하여 지연 로딩을 활성화할 수 있습니다. 지연 로딩이 활성화된 상태에서 탐색 속성(Navigation Property)에 접근하면, 해당 데이터가 필요할 때마다 쿼리가 실행됩니다. 이로 인해 반복문 안에서 여러 엔티티의 연관 데이터를 조회할 때 N + 1 문제가 발생합니다.

**예시:** '블로그'와 '포스트'가 1:N 관계일 때, 모든 블로그를 조회한 후 각 블로그의 포스트에 접근하는 경우

- **쿼리 1회:** 모든 `Blog` 엔티티를 조회합니다.
- **쿼리 N회:** 반복문에서 각 `Blog`의 `Posts` 컬렉션에 접근할 때마다, 해당 블로그의 `Post`를 조회하는 쿼리가 N번 실행됩니다.

---

### 해결 방법

두 프레임워크 모두 N + 1 문제를 해결하기 위해 주로 **즉시 로딩(Eager Loading)** 전략을 사용합니다. 이는 메인 엔티티를 조회할 때 연관된 엔티티를 함께 로드하여 쿼리 횟수를 줄이는 방식입니다.

#### JPA (Java Persistence API) - Hibernate 기준

- **Fetch Join:** `JOIN FETCH` 구문을 사용하여 연관된 엔티티를 즉시 함께 조회합니다. JPQL(JPA Query Language)을 통해 개발자가 명시적으로 제어할 수 있으며, 한 번의 쿼리로 데이터를 모두 가져옵니다.
- **`@EntityGraph`:** `@EntityGraph` 어노테이션을 사용하여 쿼리 시점에 어떤 연관 엔티티를 함께 가져올지 명시합니다. Fetch Join과 유사하게 동작하지만, 코드가 더 깔끔하고 재사용하기 좋습니다.
- **Batch Size 설정:** `hibernate.default_batch_fetch_size` 설정을 통해 연관된 엔티티를 일정 크기(예: 100)만큼 묶어서 IN 절을 사용한 배치 쿼리로 조회합니다. 쿼리 횟수를 1개로 줄이지는 못하지만, N개의 쿼리를 훨씬 적은 수의 쿼리로 줄일 수 있습니다.

#### EF Core (Entity Framework Core) 기준

- **`Include()` 메서드:** `Include()` 메서드를 사용하여 연관된 엔티티를 명시적으로 로드합니다. EF Core는 내부적으로 `LEFT JOIN` 쿼리를 생성하여 한 번에 모든 데이터를 가져옵니다. `ThenInclude()`를 사용하여 여러 단계의 연관 관계도 함께 로드할 수 있습니다.
- **프로젝션 (Projection):** `Select()` 메서드를 사용하여 필요한 데이터만 DTO(Data Transfer Object)나 익명 타입으로 가져옵니다. 이렇게 하면 `JOIN` 쿼리가 생성되어 N + 1 문제가 방지되고, 불필요한 데이터를 로드하지 않아 성능을 최적화할 수 있습니다.
- **명시적 로딩 (Explicit Loading):** `DbContext.Entry(entity).Collection(e => e.NavigationProperty).Load()`와 같이 명시적으로 `Load()` 메서드를 호출하여 필요한 시점에만 데이터를 로드할 수 있습니다. 이는 개발자가 쿼리 시점을 제어할 수 있게 합니다.

결론적으로, 두 프레임워크 모두 N + 1 문제를 해결하기 위해 `Join`을 활용한 **즉시 로딩** 전략을 제공하고 있습니다. 애플리케이션의 상황에 맞게 적절한 해결책을 선택하여 쿼리 횟수를 줄이고 성능을 최적화하는 것이 중요합니다.
