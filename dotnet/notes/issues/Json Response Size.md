## 📌 JSON 응답 크기 증가 시 발생하는 문제와 주요 원인

### ✅ 주요 발생 문제

1. **전송 지연 (Latency 증가)**

   - 네트워크를 통한 전송 시간이 길어짐

2. **클라이언트 메모리 부담**

   - 클라이언트가 전체 응답을 메모리에 적재해야 함

3. **브라우저/앱 렌더링 지연**

   - 데이터 파싱, 렌더링 시 처리 지연 발생

4. **네트워크 비용 증가**

   - 대량 데이터 전송으로 인한 트래픽 비용 증가

5. **타임아웃 오류**

   - 서버/클라이언트/프록시에서 응답 대기 시간 초과

6. **서버 부하 증가**

   - 직렬화/역직렬화, 처리 비용이 커짐

7. **클라이언트(브라우저/앱)의 최대 응답 크기 제한**

- 서버는 정상적으로 전송했으나 클라이언트 단의 메모리, 브라우저 설정, 미들웨어에서 응답을 수신하지 못하는 경우 발생
- 브라우저, 프록시, 모바일 네트워크 환경 등에 따른 수신 제한 가능성
- `Content-Length`는 포함되어 있으나 Body가 비어있는 현상 발생 가능

  - 브라우저, 프록시, 모바일 네트워크 환경 등에 따른 수신 제한 가능성

---

## 📌 대중적인 해결 방안

### 1️⃣ **페이징 (Pagination)**

- 데이터를 나눠서 페이지 단위로 요청하고 응답
- 예시: `GET /items?page=1&pageSize=50`

### 2️⃣ **필드 제한 (Field Selection / Sparse Fieldsets)**

- 필요한 데이터만 선택해서 받기
- 예시: `GET /items?fields=id,name,status`

### 3️⃣ **서버 압축 (Compression)**

- `gzip`, `brotli` 압축 전송으로 데이터 크기 축소
- HTTP 헤더 예시: `Accept-Encoding: gzip, br`

### 4️⃣ **스트리밍 (Streaming API)**

- 데이터를 한번에 보내지 않고 스트리밍 전송 (Server-Sent Events, WebSocket)
- 사용 예: 실시간 데이터, 대용량 데이터

### 5️⃣ **배치 처리 (Batch API)**

- 여러 개의 작은 요청을 묶어 하나로 처리
- 서버가 최적화된 형태로 응답을 반환

### 6️⃣ **GraphQL 활용**

- 클라이언트가 필요한 데이터 구조를 정의하여 요청
- Over-fetching 방지

### 7️⃣ **데이터 포맷 변경**

- JSON보다 효율적인 포맷 사용 (예: Protocol Buffers, MessagePack)
- 바이너리 포맷으로 크기 절감

### 8️⃣ **클라이언트 및 네트워크 환경 점검**

- 브라우저/앱의 메모리 사용량과 최대 허용 응답 크기 점검
- 프록시/방화벽/네트워크 미들웨어의 응답 크기 제한 설정 확인
- 필요시 클라이언트 코드에서 스트리밍 처리, 청크 단위 수신 등 고려
- 서버 및 프록시의 최대 응답 크기 설정도 함께 확인 (웹 서버의 `client_max_body_size`, `proxy_buffer_size`, API Gateway 설정 등)

---

## ✅ 결론

대용량 JSON 응답은 네트워크 지연과 시스템 부하를 초래하므로,
비즈니스 요구사항에 따라 위와 같은 방법을 적절히 조합하여 최적화하는 것이 중요하다.
서버 및 네트워크 인프라 설정뿐 아니라, 클라이언트 및 실행 환경의 한계도 함께 점검하여 예기치 않은 전송 실패를 방지해야 한다.

---
